<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>规则怪谈：第13号档案 (v5.0 最终版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Creepster&family=Nosifer&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root { --blood-color: #8a0b0b; }
        body { background-color: #000; color: #a8a29e; font-family: 'Noto Serif SC', serif; overflow: hidden; }
        .creep-font { font-family: 'Creepster', cursive; }
        .horror-font { font-family: 'Nosifer', cursive; }
        
        /* 恐怖氛围滤镜 */
        .vignette { position: fixed; inset: 0; background: radial-gradient(circle, transparent 40%, #000 100%); pointer-events: none; z-index: 40; }
        .noise { position: fixed; inset: 0; width: 100%; height: 100%; background: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E"); pointer-events: none; z-index: 41; opacity: 0.4; }
        .scanline { width: 100%; height: 100px; z-index: 42; background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(255, 0, 0, 0.05) 50%, rgba(0,0,0,0) 100%); opacity: 0.1; position: absolute; bottom: 100%; animation: scanline 8s linear infinite; pointer-events: none; }
        @keyframes scanline { 0% { bottom: 100%; } 100% { bottom: -100px; } }

        /* 动画特效 */
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
        
        .pulse-red { animation: pulseRed 2s infinite; }
        @keyframes pulseRed { 0% { box-shadow: inset 0 0 0 transparent; } 50% { box-shadow: inset 0 0 50px rgba(138, 11, 11, 0.5); } 100% { box-shadow: inset 0 0 0 transparent; } }

        .glitch-text { position: relative; }
        .glitch-text::before, .glitch-text::after { content: attr(data-text); position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.8; }
        .glitch-text::before { color: #f00; z-index: -1; animation: glitch-anim-1 0.4s infinite linear alternate-reverse; }
        .glitch-text::after { color: #00f; z-index: -2; animation: glitch-anim-2 0.4s infinite linear alternate-reverse; }
        @keyframes glitch-anim-1 { 0% { clip-path: inset(20% 0 80% 0); transform: translate(-2px,0); } 100% { clip-path: inset(60% 0 10% 0); transform: translate(2px,0); } }
        @keyframes glitch-anim-2 { 0% { clip-path: inset(10% 0 50% 0); transform: translate(2px,0); } 100% { clip-path: inset(80% 0 5% 0); transform: translate(-2px,0); } }

        /* 聊天气泡 */
        .msg-bubble { max-width: 80%; padding: 8px 12px; border-radius: 8px; font-size: 0.85rem; margin-bottom: 8px; position: relative; word-break: break-all; }
        .msg-left { background: #1c1917; border: 1px solid #292524; color: #a8a29e; align-self: flex-start; border-bottom-left-radius: 0; }
        .msg-right { background: #450a0a; border: 1px solid #7f1d1d; color: #fecaca; align-self: flex-end; border-bottom-right-radius: 0; }
        
        /* 自定义滚动条 */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; }

        /* 突脸层 */
        #jumpscare { pointer-events: none; opacity: 0; transition: opacity 0.1s; background: black; z-index: 100; }
        .face-flash { animation: flashFace 0.2s 2; }
        @keyframes flashFace { 0% { opacity: 0; transform: scale(1); } 50% { opacity: 1; transform: scale(1.2); } 100% { opacity: 0; transform: scale(1); } }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center relative text-sm md:text-base selection:bg-red-900 selection:text-white">

    <div class="vignette"></div>
    <div class="noise"></div>
    <div class="scanline"></div>
    
    <!-- JUMPSCARE LAYER -->
    <div id="jumpscare" class="fixed inset-0 flex items-center justify-center">
        <svg viewBox="0 0 200 200" class="w-full h-full text-red-900 fill-current">
            <path d="M100,20 C50,20 20,60 20,100 C20,150 50,180 100,180 C150,180 180,150 180,100 C180,60 150,20 100,20 Z M60,80 C50,80 45,90 60,100 C75,110 80,90 70,80 Z M140,80 C130,80 125,90 140,100 C155,110 160,90 150,80 Z M100,160 C70,160 60,130 100,120 C140,130 130,160 100,160 Z" />
        </svg>
    </div>

    <!-- LOADING / RECONNECT -->
    <div id="loading-overlay" class="fixed inset-0 bg-black z-50 flex flex-col items-center justify-center hidden">
        <div class="text-red-700 creep-font text-2xl animate-pulse">CONNECTING...</div>
        <div id="loading-text" class="text-zinc-600 text-xs mt-2 font-mono">正在尝试恢复神经连接...</div>
    </div>

    <!-- MAIN MENU -->
    <div id="screen-menu" class="w-full max-w-md p-8 text-center z-10 relative">
        <h1 class="text-6xl text-red-800 creep-font tracking-widest mb-2 glitch-text cursor-default" data-text="FILE #13">FILE #13</h1>
        <p class="text-zinc-600 text-xs tracking-[0.5em] uppercase mb-12 border-b border-red-900/30 pb-2 inline-block">v5.0 终极重制版</p>
        
        <div class="space-y-6">
            <div class="relative group">
                <input type="text" id="p-name" class="w-full bg-transparent border-b border-zinc-700 text-center text-zinc-300 p-3 focus:outline-none focus:border-red-600 transition font-serif placeholder-zinc-800 uppercase tracking-widest" placeholder="ENTER CODENAME">
                <div class="absolute bottom-0 left-0 w-full h-[1px] bg-red-900 transform scale-x-0 group-hover:scale-x-100 transition-transform duration-500"></div>
            </div>
            
            <div class="grid grid-cols-2 gap-4">
                <button onclick="Game.init('OFFLINE')" class="group relative overflow-hidden bg-zinc-950 border border-zinc-800 p-4 hover:border-red-800 transition duration-500">
                    <div class="absolute inset-0 bg-red-950/20 transform translate-y-full group-hover:translate-y-0 transition-transform duration-500"></div>
                    <i data-lucide="bot" class="w-8 h-8 mx-auto mb-2 text-zinc-600 group-hover:text-red-500 transition-colors"></i>
                    <div class="font-bold text-zinc-400 group-hover:text-red-100 relative z-10">离线单人</div>
                    <div class="text-[10px] text-zinc-700 mt-1">AI 队友模拟</div>
                </button>
                <button onclick="UI.toggleOnlineSetup()" class="group relative overflow-hidden bg-zinc-950 border border-zinc-800 p-4 hover:border-red-800 transition duration-500">
                    <div class="absolute inset-0 bg-red-950/20 transform translate-y-full group-hover:translate-y-0 transition-transform duration-500"></div>
                    <i data-lucide="skull" class="w-8 h-8 mx-auto mb-2 text-zinc-600 group-hover:text-red-500 transition-colors"></i>
                    <div class="font-bold text-zinc-400 group-hover:text-red-100 relative z-10">在线联机</div>
                    <div class="text-[10px] text-zinc-700 mt-1">云端数据同步</div>
                </button>
            </div>
        </div>
        
        <!-- Online Setup Panel -->
        <div id="online-setup" class="hidden mt-6 p-6 bg-black border border-red-900/30 rounded text-left relative overflow-hidden">
            <div class="absolute top-0 left-0 w-1 h-full bg-red-900"></div>
            <label class="text-[10px] text-red-900/70 uppercase tracking-widest block mb-2">Secure Channel ID</label>
            <input type="text" id="p-room" class="w-full bg-zinc-900/50 border border-zinc-800 p-2 text-red-100 font-mono text-sm focus:border-red-900 focus:outline-none mb-4" placeholder="例如: 101">
            <button id="btn-connect" onclick="Game.init('ONLINE')" class="w-full bg-red-950 hover:bg-red-900 text-red-200 py-2 text-xs border border-red-900 tracking-widest transition uppercase">连接服务器</button>
            <div id="connect-status" class="text-[10px] text-center mt-2 h-4 text-red-500 font-mono"></div>
        </div>
    </div>

    <!-- ROLE SELECTION -->
    <div id="screen-role" class="hidden w-full max-w-5xl p-6 z-10">
        <h2 class="text-4xl text-center text-red-800 mb-12 font-serif tracking-widest creep-font border-b border-red-900/20 pb-4">选择你的命运</h2>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-8" id="role-grid">
            <!-- Roles injected via JS -->
        </div>
    </div>

    <!-- GAMEPLAY HUD -->
    <div id="screen-game" class="hidden w-full h-screen flex flex-col md:flex-row overflow-hidden bg-black relative z-10">
        
        <!-- LEFT: CHAT & LOGS -->
        <div class="w-full md:w-1/4 border-r border-zinc-900 flex flex-col h-[40vh] md:h-full bg-zinc-950/80 backdrop-blur-sm">
            <div class="p-3 border-b border-zinc-900 bg-black flex justify-between items-center">
                <h3 class="text-red-900 font-bold text-xs tracking-[0.2em] flex items-center gap-2">
                    <span class="w-2 h-2 bg-red-600 rounded-full animate-pulse"></span> RADIO_13
                </h3>
                <span id="game-mode-display" class="text-[10px] font-mono text-zinc-600">OFFLINE</span>
            </div>
            
            <!-- Chat Box -->
            <div id="chat-box" class="flex-grow overflow-y-auto p-4 flex flex-col gap-2">
                <div class="text-center text-zinc-800 text-[10px] font-mono my-2">- ENCRYPTED CONNECTION -</div>
            </div>
            
            <form onsubmit="Game.sendChat(event)" class="p-3 border-t border-zinc-900 bg-black flex gap-2">
                <input id="chat-input" type="text" class="flex-grow bg-zinc-900 border border-zinc-800 text-zinc-300 text-xs px-3 py-2 focus:border-red-900 outline-none placeholder-zinc-700" placeholder="发送消息 (Enter)..." autocomplete="off">
                <button type="submit" class="bg-red-950/30 hover:bg-red-900 text-red-500 px-3 border border-red-900/30 transition"><i data-lucide="send" class="w-3 h-3"></i></button>
            </form>
        </div>

        <!-- CENTER: MAIN STAGE -->
        <div class="w-full md:w-1/2 relative flex flex-col h-[60vh] md:h-full border-r border-zinc-900">
            <!-- Rule Note -->
            <div class="absolute top-4 right-4 z-30 cursor-pointer hover:scale-105 transition duration-300" onclick="UI.toggleRules()">
                <div class="bg-yellow-100/90 text-black p-2 w-40 text-[10px] font-serif shadow-[0_0_20px_rgba(0,0,0,0.8)] rotate-1 transform border-t-4 border-yellow-600/50">
                    <div class="font-bold border-b border-black/10 pb-1 mb-1 text-red-900">生存守则 (点击)</div>
                    <div id="mini-rule-text" class="leading-tight opacity-80">加载中...</div>
                </div>
            </div>

            <!-- Stage Content -->
            <div class="flex-grow flex flex-col items-center justify-center p-8 relative">
                <!-- Background Round Number -->
                <div id="round-indicator" class="text-[15rem] font-bold text-red-900/5 select-none absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-none creep-font">1</div>

                <div class="relative z-10 w-full max-w-lg text-center">
                    <div id="event-type-badge" class="inline-block px-2 py-1 border border-red-900/50 text-red-600 text-[10px] tracking-[0.2em] mb-6 bg-black">异常侦测</div>
                    
                    <div id="ai-loading" class="hidden text-red-800 font-mono text-xs mb-4 ai-generating">
                        [AI 重构现实中...]
                    </div>

                    <h2 id="event-desc" class="text-xl md:text-2xl font-serif text-zinc-300 leading-relaxed mb-10 min-h-[100px] flex items-center justify-center drop-shadow-[0_2px_10px_rgba(0,0,0,1)]">
                        等待信号接入...
                    </h2>
                    
                    <div id="action-container" class="space-y-3 w-full opacity-0 translate-y-4 transition-all duration-500 ease-out" style="opacity: 1; transform: none;">
                        <!-- Actions injected here -->
                    </div>
                    
                    <div id="waiting-text" class="hidden mt-6 flex flex-col items-center gap-2 text-zinc-600">
                        <div class="w-6 h-6 border-2 border-red-900 border-t-transparent rounded-full animate-spin"></div>
                        <span class="text-xs font-mono animate-pulse">等待其他幸存者...</span>
                    </div>
                </div>
            </div>

            <!-- Player Status Bar -->
            <div class="bg-black border-t border-zinc-900 p-4 flex justify-between items-center text-zinc-500 font-mono text-xs">
                <div class="flex items-center gap-6">
                    <div class="flex flex-col">
                        <span class="text-[9px] uppercase tracking-widest text-zinc-700">Sanity</span>
                        <div class="text-xl font-bold text-red-600 flex items-center gap-2">
                            <i data-lucide="activity" class="w-4 h-4"></i> <span id="my-san">100</span>
                        </div>
                    </div>
                    <div class="w-[1px] h-8 bg-zinc-900"></div>
                    <div class="flex flex-col">
                        <span class="text-[9px] uppercase tracking-widest text-zinc-700">Identity</span>
                        <div id="my-role-display" class="text-sm text-zinc-300 font-bold">---</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT: SQUAD STATUS -->
        <div class="w-full md:w-1/4 bg-zinc-950/50 p-4 h-full overflow-y-auto hidden md:block">
            <h3 class="text-zinc-600 text-[10px] uppercase tracking-[0.2em] mb-4 border-b border-zinc-900 pb-2 flex justify-between">
                <span>Squad Status</span>
                <i data-lucide="users" class="w-3 h-3"></i>
            </h3>
            <div id="team-list" class="space-y-2">
                <!-- Teammates -->
            </div>
            
            <div class="mt-8">
                <h4 class="text-red-900/50 text-[10px] font-bold mb-2 font-mono">SYSTEM LOGS</h4>
                <div id="game-log" class="text-[10px] font-mono text-zinc-600 space-y-1 max-h-48 overflow-y-auto custom-scrollbar"></div>
            </div>
        </div>
    </div>

    <!-- MODALS -->
    <div id="modal-rules" class="fixed inset-0 bg-black/95 z-50 hidden flex items-center justify-center p-4 backdrop-blur-sm" onclick="UI.toggleRules()">
        <div class="paper-texture w-full max-w-md p-8 rounded shadow-[0_0_50px_rgba(0,0,0,1)] relative rotate-1 border border-zinc-800" onclick="event.stopPropagation()">
            <h2 class="text-3xl font-bold text-red-900 mb-6 border-b-2 border-black/10 pb-2 text-center creep-font tracking-widest">员工守则</h2>
            <div id="full-rules-list" class="space-y-4 text-black/90 font-serif text-sm font-bold"></div>
            <div class="mt-6 text-right text-[10px] text-red-900 font-mono">DO NOT DISOBEY</div>
        </div>
    </div>

    <div id="modal-end" class="fixed inset-0 bg-black z-50 hidden flex flex-col items-center justify-center text-center p-6">
        <div id="end-icon-container" class="mb-6 animate-bounce"></div>
        <h1 id="end-title" class="text-7xl text-red-600 creep-font mb-4 tracking-widest"></h1>
        <p id="end-msg" class="text-zinc-400 max-w-xl text-lg mb-10 font-serif leading-relaxed"></p>
        <button onclick="localStorage.removeItem('gh_room'); location.reload()" class="bg-red-950 hover:bg-red-900 text-white px-8 py-3 border border-red-800 transition uppercase tracking-widest text-sm">重新轮回</button>
    </div>

    <!-- LOGIC -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, onSnapshot, updateDoc, serverTimestamp, addDoc, query, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- 1. FIREBASE SETUP ---
        const firebaseConfig = {
          apiKey: "AIzaSyCpu1t0FSuHyrFXbksI8synpehhf-VemDE",
          authDomain: "guizeguaitan-2e9e7.firebaseapp.com",
          projectId: "guizeguaitan-2e9e7",
          storageBucket: "guizeguaitan-2e9e7.firebasestorage.app",
          messagingSenderId: "4402832828",
          appId: "1:4402832828:web:5f77820b9c36f228a837b9",
          measurementId: "G-FRRM5MP58D"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = 'guizeguaitan-v5'; 

        const ARK_CONFIG = {
            url: "https://ark.cn-beijing.volces.com/api/v3/chat/completions",
            model: "ep-20251202113657-f9jtz",
            key: "91927eff-26b4-4a5a-8db5-fcf35b1ee6a5"
        };

        // --- 2. GAME CONTENT ---
        const ROLES = {
            MEDIC: { id: 'MEDIC', name: '校医', icon: 'stethoscope', desc: '心理素质极佳，每回合自动回复 5 点 SAN 值。', color: 'text-green-500' },
            DETECTIVE: { id: 'DETECTIVE', name: '侦探', icon: 'search', desc: '观察力敏锐，AI 会在事件中给予额外提示。', color: 'text-blue-500' },
            BRUTE: { id: 'BRUTE', name: '保安', icon: 'shield', desc: '皮糙肉厚，SAN 值上限 150，受到的伤害减半。', color: 'text-red-500' }
        };

        const RULES = [
            "如果你看见红色的灯光，必须立刻闭眼，否则视网膜会融化。",
            "不要回应任何喊你名字的声音，除非你确定对方拿着提灯。",
            "博物馆里没有猫。如果你看见猫，那是“它”的伪装。",
            "画中的人如果在流血，请赞美它，它喜欢虚伪的赞美。",
            "如果听到铁链声，必须保持像死人一样静止不动。"
        ];

        const EVENT_SEEDS = [
            { seed: "走廊灯光变红", type: "red_light", options: [{txt:"闭眼摸索", type:"safe"}, {txt:"转身逃跑", type:"bad", val:20}, {txt:"直视光源", type:"dead"}] },
            { seed: "身后传来铁链声", type: "chains", options: [{txt:"原地不动", type:"safe"}, {txt:"回头查看", type:"bad", val:25}, {txt:"拔腿就跑", type:"bad", val:35}] },
            { seed: "黑猫挡路", type: "cat", options: [{txt:"绕道而行", type:"safe"}, {txt:"伸手抚摸", type:"dead"}, {txt:"大声驱赶", type:"bad", val:15}] },
            { seed: "画中人流血泪", type: "painting", options: [{txt:"赞美画作", type:"heal", val:15}, {txt:"擦拭血迹", type:"bad", val:30}, {txt:"无视离开", type:"bad", val:10}] }
        ];

        // --- 3. UI CONTROLLER ---
        window.UI = {
            toggleOnlineSetup: () => {
                const el = document.getElementById('online-setup');
                el.classList.toggle('hidden');
                // Auto-fill from local storage if available
                const savedRoom = localStorage.getItem('gh_room');
                if(savedRoom) document.getElementById('p-room').value = savedRoom;
            },
            
            showScreen: (id) => {
                ['screen-menu', 'screen-role', 'screen-game'].forEach(s => document.getElementById(s).classList.add('hidden'));
                document.getElementById(id).classList.remove('hidden');
            },

            renderRoles: () => {
                const grid = document.getElementById('role-grid');
                grid.innerHTML = Object.values(ROLES).map(r => `
                    <div onclick="Game.selectRole('${r.id}')" class="bg-zinc-950 border border-zinc-800 p-6 hover:border-red-900 hover:bg-zinc-900 cursor-pointer transition group relative overflow-hidden">
                        <div class="absolute inset-0 bg-red-900/5 transform scale-x-0 group-hover:scale-x-100 transition-transform origin-left duration-300"></div>
                        <i data-lucide="${r.icon}" class="w-10 h-10 mb-4 ${r.color} group-hover:scale-110 transition-transform"></i>
                        <h3 class="text-2xl font-bold text-zinc-300 group-hover:text-white mb-2 creep-font tracking-wider">${r.name}</h3>
                        <p class="text-zinc-600 text-xs leading-relaxed group-hover:text-zinc-400 font-mono">${r.desc}</p>
                    </div>
                `).join('');
                lucide.createIcons();
            },

            renderEvent: () => {
                const evt = Game.currentEvent;
                const descEl = document.getElementById('event-desc');
                
                // Animation reset
                descEl.style.opacity = '0';
                setTimeout(() => {
                    descEl.innerText = evt.text; // Display AI text
                    descEl.style.opacity = '1';
                }, 200);

                document.getElementById('round-indicator').innerText = Game.turn;
                document.getElementById('mini-rule-text').innerText = RULES[Math.floor(Math.random()*RULES.length)];

                const container = document.getElementById('action-container');
                container.innerHTML = '';
                
                evt.options.forEach((opt, idx) => {
                    const btn = document.createElement('button');
                    btn.className = "w-full text-left p-4 bg-zinc-950 border border-zinc-800 hover:border-red-800 hover:bg-zinc-900 transition text-zinc-400 rounded group flex items-center";
                    btn.innerHTML = `
                        <span class="w-2 h-2 bg-red-900 mr-3 opacity-0 group-hover:opacity-100 transition-opacity"></span>
                        <span class="font-bold group-hover:text-red-100 transition font-serif text-sm tracking-wider">${opt.txt}</span>
                    `;
                    btn.onclick = () => Game.resolveAction(idx);
                    container.appendChild(btn);
                });
            },

            updateTeam: () => {
                const list = [...Game.players].sort((a,b) => (a.uid===Game.userId ? -1 : 1));
                
                // Update My HUD
                if (Game.me) {
                    const sanEl = document.getElementById('my-san');
                    sanEl.innerText = Game.me.san;
                    
                    // Horror Effects based on SAN
                    if (Game.me.san <= 50) document.body.classList.add('pulse-red');
                    else document.body.classList.remove('pulse-red');
                    
                    if(Game.me.role) document.getElementById('my-role-display').innerText = ROLES[Game.me.role].name;
                }

                document.getElementById('team-list').innerHTML = list.map(p => {
                    const roleName = p.role ? ROLES[p.role].name : '未选择';
                    const isDead = p.status === 'DEAD';
                    return `
                    <div class="flex items-center justify-between p-2 border-b border-zinc-900 ${p.uid===Game.userId ? 'bg-red-950/10 border-l-2 border-red-800' : ''} ${isDead ? 'opacity-30 grayscale' : ''}">
                        <div>
                            <div class="text-xs font-bold ${p.uid===Game.userId ? 'text-white' : 'text-zinc-500'} font-mono">${p.name}</div>
                            <div class="text-[9px] text-zinc-700 uppercase tracking-wider">${roleName}</div>
                        </div>
                        <div class="text-right">
                            <div class="text-[10px] font-mono font-bold ${p.san < 30 ? 'text-red-500 animate-pulse' : 'text-zinc-600'}">SAN: ${p.san}</div>
                            <div class="text-[9px] ${isDead ? 'text-red-800 font-bold' : 'text-green-900'}">${p.status}</div>
                        </div>
                    </div>`;
                }).join('');
            },

            addLog: (msg) => {
                const log = document.getElementById('game-log');
                const div = document.createElement('div');
                div.className = "border-l border-zinc-800 pl-2 text-zinc-500";
                div.innerHTML = `<span class="text-red-900 font-bold mr-1">>></span> ${msg}`;
                log.prepend(div);
            },

            addChat: (name, msg, isSystem = false) => {
                const box = document.getElementById('chat-box');
                const div = document.createElement('div');
                const isMe = name === Game.userName;
                
                if (isSystem) {
                    div.className = "text-center text-[9px] text-red-900/50 font-mono my-1";
                    div.innerText = msg;
                } else {
                    div.className = `msg-bubble ${isMe ? 'msg-right' : 'msg-left'}`;
                    div.innerHTML = `<strong class="block text-[9px] opacity-50 mb-1 font-mono uppercase tracking-wider ${isMe ? 'text-right' : 'text-left'}">${name}</strong>${msg}`;
                }
                
                box.appendChild(div);
                box.scrollTop = box.scrollHeight;
            },

            jumpscare: () => {
                const el = document.getElementById('jumpscare');
                el.classList.remove('hidden');
                el.classList.add('face-flash');
                setTimeout(() => {
                    el.classList.remove('face-flash');
                    el.classList.add('hidden');
                }, 500);
            },

            shake: () => {
                document.body.classList.add('shake');
                setTimeout(() => document.body.classList.remove('shake'), 500);
            },

            toggleRules: () => {
                const modal = document.getElementById('modal-rules');
                modal.classList.toggle('hidden');
                document.getElementById('full-rules-list').innerHTML = RULES.map((r,i) => `<p class="border-b border-black/10 pb-1 mb-1">${i+1}. ${r}</p>`).join('');
            }
        };

        // --- 4. GAME ENGINE ---
        window.Game = {
            mode: 'OFFLINE',
            turn: 0,
            roomId: null,
            userId: null,
            userName: "幸存者",
            players: [], 
            me: null,    
            currentEvent: null,
            isHost: false,
            
            init: async (mode) => {
                const nameInput = document.getElementById('p-name').value.trim();
                Game.userName = nameInput || `No.${Math.floor(Math.random()*1000)}`;
                Game.mode = mode;

                // Save name for persistence
                localStorage.setItem('gh_username', Game.userName);

                if (mode === 'OFFLINE') {
                    Game.setupOffline();
                } else {
                    await Game.setupOnline();
                }
            },

            // --- OFFLINE MODE ---
            setupOffline: () => {
                Game.isHost = true;
                Game.userId = 'me';
                Game.players = [
                    { uid: 'me', name: Game.userName, role: null, san: 100, status: 'ALIVE', isBot: false },
                    { uid: 'bot1', name: "老王", role: 'BRUTE', san: 150, status: 'ALIVE', isBot: true },
                    { uid: 'bot2', name: "Sarah", role: 'MEDIC', san: 100, status: 'ALIVE', isBot: true }
                ];
                Game.me = Game.players[0];
                UI.showScreen('screen-role');
                UI.renderRoles();
            },

            // --- ONLINE MODE (FIXED & PERSISTENT) ---
            setupOnline: async () => {
                const btn = document.getElementById('btn-connect');
                const status = document.getElementById('connect-status');
                
                // 1. Get Room ID (from input or storage)
                let roomId = document.getElementById('p-room').value.trim();
                if (!roomId) roomId = localStorage.getItem('gh_room');
                
                if (!roomId) {
                    status.innerText = "ERROR: 请输入房间号";
                    return;
                }

                Game.roomId = roomId;
                localStorage.setItem('gh_room', roomId); // Save for refresh persistence

                btn.disabled = true;
                btn.innerText = "CONNECTING...";
                document.getElementById('loading-overlay').classList.remove('hidden');

                try {
                    await signInAnonymously(auth);
                    Game.userId = auth.currentUser.uid;

                    // Room Handling
                    const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${Game.roomId}`);
                    const playerRef = doc(db, 'artifacts', appId, 'public', 'data', `room_${Game.roomId}_players`, Game.userId);

                    const roomSnap = await getDoc(roomRef);
                    if (!roomSnap.exists()) {
                        Game.isHost = true;
                        await setDoc(roomRef, {
                            status: 'LOBBY',
                            currentRound: 0,
                            hostId: Game.userId // Store Host ID
                        });
                    } else {
                        // Check if I am the returning host
                        const data = roomSnap.data();
                        if (data.hostId === Game.userId) {
                            Game.isHost = true;
                            console.log("Welcome back, Host.");
                        }
                    }

                    // Player Registration (Always update latest name)
                    await setDoc(playerRef, {
                        uid: Game.userId,
                        name: Game.userName,
                        role: null, // Reset role on fresh join, or keep if persisted? Let's reset for safety unless checking
                        san: 100,
                        status: 'ALIVE',
                        isBot: false,
                        lastSeen: serverTimestamp()
                    }, { merge: true }); // Merge to avoid overwriting existing role if simply refreshing? No, simpler to re-pick role on refresh

                    // Listeners
                    Game.listenToRoom();
                    Game.listenToPlayers();
                    Game.listenToChat();

                    document.getElementById('loading-overlay').classList.add('hidden');
                    UI.showScreen('screen-role');
                    UI.renderRoles();
                    document.getElementById('game-mode-display').innerText = `ONLINE: ${Game.roomId}`;

                } catch (e) {
                    console.error(e);
                    document.getElementById('loading-overlay').classList.add('hidden');
                    status.innerText = "Connection Failed";
                    btn.disabled = false;
                    btn.innerText = "RETRY";
                }
            },

            // --- GAMEPLAY ---
            selectRole: async (roleId) => {
                let maxSan = roleId === 'BRUTE' ? 150 : 100;
                
                if (Game.mode === 'OFFLINE') {
                    Game.me.role = roleId;
                    Game.me.san = maxSan;
                    UI.showScreen('screen-game');
                    Game.startTurn();
                } else {
                    const playerRef = doc(db, 'artifacts', appId, 'public', 'data', `room_${Game.roomId}_players`, Game.userId);
                    await updateDoc(playerRef, { role: roleId, san: maxSan });
                    
                    UI.showScreen('screen-game');
                    document.getElementById('event-desc').innerText = "等待信号接入... (Wait for Host)";
                    
                    if (Game.isHost) setTimeout(() => Game.startTurn(), 2000);
                }
            },

            startTurn: async () => {
                if (!Game.isHost) return;
                Game.turn++;
                const seed = EVENT_SEEDS[Math.floor(Math.random() * EVENT_SEEDS.length)];
                
                let finalText = seed.seed;
                
                // AI Generation Call
                try {
                    if(Game.mode === 'OFFLINE') {
                        document.getElementById('ai-loading').classList.remove('hidden');
                        document.getElementById('event-desc').innerText = "AI 正在重构恐怖现实...";
                    }
                    
                    const prompt = `你是一个克苏鲁恐怖游戏主持人。当前第 ${Game.turn} 回合。基础事件是："${seed.seed}"。
                    请扩写成一段极度恐怖、血腥、令人不安的场景描述。字数50字以内。
                    不要提选项。`;
                    
                    const aiRes = await ARK.call(prompt);
                    if (aiRes) finalText = aiRes;
                } catch (e) { console.warn("AI skipped"); }

                const eventData = { text: finalText, type: seed.type, options: seed.options, turn: Game.turn };

                if (Game.mode === 'OFFLINE') {
                    Game.currentEvent = eventData;
                    document.getElementById('ai-loading').classList.add('hidden');
                    UI.renderEvent();
                    Game.simulateBots(); // Bots act
                } else {
                    const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${Game.roomId}`);
                    await updateDoc(roomRef, { status: 'PLAYING', currentRound: Game.turn, currentEvent: eventData });
                }
            },

            resolveAction: async (optIdx) => {
                const evt = Game.currentEvent;
                const opt = evt.options[optIdx];
                let dSan = 0;
                let logMsg = "";

                if (opt.type === 'safe') {
                    logMsg = "暂时安全";
                } else if (opt.type === 'heal') {
                    dSan = opt.val;
                    logMsg = "恢复了理智";
                } else if (opt.type === 'bad') {
                    dSan = -opt.val;
                    if (Game.me.role === 'BRUTE') dSan = Math.floor(dSan * 0.5); // Brute perk
                    logMsg = "受到了精神冲击";
                    UI.shake();
                    UI.jumpscare(); // Small jumpscare on damage
                } else if (opt.type === 'dead') {
                    dSan = -999;
                    logMsg = "触发了必死规则";
                    UI.jumpscare(); // BIG jumpscare
                }

                // Medic Perk: Passive Heal
                if (Game.me.role === 'MEDIC' && dSan >= 0) dSan += 5;

                const newSan = Math.max(0, Game.me.san + dSan);
                const newStatus = newSan <= 0 ? 'DEAD' : 'ALIVE';

                // Send Chat about action (Auto)
                const actionText = `选择了 [${opt.txt}]，${logMsg}。`;
                Game.sendChat(null, actionText, true);

                if (Game.mode === 'OFFLINE') {
                    Game.me.san = newSan;
                    Game.me.status = newStatus;
                    UI.updateTeam();
                    
                    document.getElementById('action-container').classList.add('opacity-0', 'translate-y-4'); // Anim out
                    document.getElementById('waiting-text').classList.remove('hidden');
                    
                    if (newStatus === 'DEAD') {
                        setTimeout(() => Game.end("YOU_DIED"), 1000);
                        return;
                    }

                    setTimeout(() => {
                        document.getElementById('action-container').classList.remove('opacity-0', 'translate-y-4');
                        document.getElementById('waiting-text').classList.add('hidden');
                        Game.startTurn();
                    }, 3000);
                } else {
                    const playerRef = doc(db, 'artifacts', appId, 'public', 'data', `room_${Game.roomId}_players`, Game.userId);
                    await updateDoc(playerRef, { san: newSan, status: newStatus, lastActionRound: Game.turn });
                    
                    document.getElementById('action-container').classList.add('hidden');
                    document.getElementById('waiting-text').classList.remove('hidden');
                    
                    if (newStatus === 'DEAD') {
                       // Stay in game but dead
                       UI.addLog("你已确认死亡。");
                    }
                }
            },

            // --- LISTENERS ---
            listenToRoom: () => {
                onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${Game.roomId}`), (snap) => {
                    if (!snap.exists()) return;
                    const data = snap.data();
                    
                    if (data.currentRound > Game.turn) {
                        Game.turn = data.currentRound;
                        Game.currentEvent = data.currentEvent;
                        UI.renderEvent();
                        
                        document.getElementById('action-container').classList.remove('hidden');
                        document.getElementById('waiting-text').classList.add('hidden');
                        UI.addLog(`--- 第 ${Game.turn} 回合开始 ---`);
                    }
                });
            },

            listenToPlayers: () => {
                onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', `room_${Game.roomId}_players`), (snap) => {
                    const players = [];
                    snap.forEach(d => players.push(d.data()));
                    Game.players = players;
                    
                    const me = players.find(p => p.uid === Game.userId);
                    if (me) Game.me = me;

                    UI.updateTeam();

                    // Host Logic: Check Sync
                    if (Game.isHost && Game.state !== 'MENU') {
                        const alive = players.filter(p => p.status === 'ALIVE');
                        if (alive.length === 0 && Game.turn > 0) {
                            // Game Over logic (everyone dead)
                            return; 
                        }
                        const allActed = alive.every(p => p.lastActionRound === Game.turn);
                        if (allActed && alive.length > 0) setTimeout(() => Game.startTurn(), 1500);
                    }
                });
            },

            // --- REAL-TIME CHAT (NEW) ---
            listenToChat: () => {
                // Creates a subcollection for chat
                const q = query(collection(db, 'artifacts', appId, 'public', 'data', `room_${Game.roomId}_messages`), orderBy('timestamp', 'asc'), limit(50));
                
                onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            const data = change.doc.data();
                            UI.addChat(data.name, data.text, data.isSystem);
                        }
                    });
                });
            },

            sendChat: async (e, textOverride = null, isSystem = false) => {
                if (e) e.preventDefault();
                let txt = textOverride;
                
                if (!txt) {
                    const input = document.getElementById('chat-input');
                    txt = input.value.trim();
                    input.value = '';
                }
                
                if (!txt) return;

                if (Game.mode === 'OFFLINE') {
                    UI.addChat(Game.userName, txt, isSystem);
                } else {
                    // Send to Firestore
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'data', `room_${Game.roomId}_messages`), {
                        name: Game.userName,
                        text: txt,
                        isSystem: isSystem,
                        timestamp: serverTimestamp()
                    });
                }
            },

            // Bots
            simulateBots: () => {
                Game.players.forEach(p => {
                    if (p.isBot && p.status === 'ALIVE') {
                        setTimeout(() => {
                            const dmg = Math.random() > 0.7 ? 20 : 0;
                            p.san -= dmg;
                            if (p.san <= 0) p.status = 'DEAD';
                            UI.updateTeam();
                            // Bot Chat
                            if(dmg > 0) UI.addChat(p.name, "该死！有点疼...", false);
                        }, 1000 + Math.random() * 2000);
                    }
                });
            },
            
            end: (type) => {
                const modal = document.getElementById('modal-end');
                modal.classList.remove('hidden');
                document.getElementById('end-title').innerText = "YOU DIED";
                document.getElementById('end-msg').innerText = "你的理智已归零，你成为了第13号档案的一部分。";
            }
        };

        const ARK = {
            call: async (prompt) => {
                try {
                    const res = await fetch(ARK_CONFIG.url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${ARK_CONFIG.key}` },
                        body: JSON.stringify({ model: ARK_CONFIG.model, messages: [{ role: "system", content: "你是一个恐怖游戏的内容生成引擎。输出必须简短、黑暗、有克苏鲁风格。" }, { role: "user", content: prompt }] })
                    });
                    const data = await res.json();
                    return data.choices[0].message.content;
                } catch (e) { return null; }
            }
        };

        // Init
        lucide.createIcons();
        
        // Auto-Check Resume on Load
        window.addEventListener('load', () => {
            const savedRoom = localStorage.getItem('gh_room');
            if (savedRoom) {
               // Optional: Auto-connect logic or just prompt user
               console.log("Found saved session:", savedRoom);
            }
        });

    </script>
</body>
</html>
